package com.jvmu.bytecode;

import java.lang.reflect.*;
import java.util.*;

/**
 * Custom bytecode generator extending the JDK internal AccessorGenerator
 * Provides arbitrary bytecode generation capabilities beyond reflection accessors
 */
public class ArbitraryBytecodeGenerator {
    private static Class<?> classFileAssemblerClass;
    private static Object byteVectorCreate;
    private static Method defineClassMethod;

    static {
        try {
            initializeBytecodeInfrastructure();
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize bytecode generation", e);
        }
    }

    private static void initializeBytecodeInfrastructure() throws Exception {
        classFileAssemblerClass = Class.forName("jdk.internal.reflect.ClassFileAssembler");
        Class<?> byteVectorFactoryClass = Class.forName("jdk.internal.reflect.ByteVectorFactory");
        Class<?> classDefinerClass = Class.forName("jdk.internal.reflect.ClassDefiner");
        Method createMethod = byteVectorFactoryClass.getDeclaredMethod("create");
        createMethod.setAccessible(true);
        byteVectorCreate = createMethod;
        defineClassMethod = classDefinerClass.getDeclaredMethod("defineClass",
                String.class, byte[].class, int.class, int.class, ClassLoader.class);
        defineClassMethod.setAccessible(true);
    }

    /**
     * Generate a new class with arbitrary bytecode
     */
    public static Class<?> generateClass(String className, BytecodeBuilder builder) {
        try {
            // Create ByteVector for bytecode storage
            Object byteVector = ((Method) byteVectorCreate).invoke(null);

            // Create ClassFileAssembler
            Constructor<?> asmConstructor = classFileAssemblerClass.getDeclaredConstructor(
                    Class.forName("jdk.internal.reflect.ByteVector"));
            asmConstructor.setAccessible(true);
            Object assembler = asmConstructor.newInstance(byteVector);

            // Let the builder generate the bytecode
            builder.generateBytecode(new BytecodeAssembler(assembler));

            // Get the generated bytecode
            Method getDataMethod = byteVector.getClass().getDeclaredMethod("getData");
            getDataMethod.setAccessible(true);
            byte[] bytecode = (byte[]) getDataMethod.invoke(byteVector);

            Method getLengthMethod = byteVector.getClass().getDeclaredMethod("getLength");
            getLengthMethod.setAccessible(true);
            int length = (Integer) getLengthMethod.invoke(byteVector);

            // Define the class using ClassDefiner

            return (Class<?>) defineClassMethod.invoke(null,
                    className, bytecode, 0, length, ArbitraryBytecodeGenerator.class.getClassLoader());

        } catch (Exception e) {
            throw new RuntimeException("Failed to generate bytecode class: " + className, e);
        }
    }

    /**
     * Interface for bytecode building
     */
    public interface BytecodeBuilder {
        void generateBytecode(BytecodeAssembler assembler) throws Exception;
    }

    /**
     * Wrapper around ClassFileAssembler for easier bytecode generation
     */
    public static class BytecodeAssembler {
        private final Object assembler;
        private final Map<String, Method> methods;

        public BytecodeAssembler(Object assembler) {
            this.assembler = assembler;
            this.methods = new HashMap<>();
            cacheMethods();
        }

        private void cacheMethods() {
            try {
                Class<?> asmClass = assembler.getClass();

                // Cache methods, being careful about overloads
                for (Method method : asmClass.getDeclaredMethods()) {
                    method.setAccessible(true);
                    
                    // Special handling for emitShort - we want the single parameter version
                    if (method.getName().equals("emitShort")) {
                        if (method.getParameterCount() == 1) {
                            methods.put("emitShort", method);
                        }
                        // Skip the 2-parameter version
                    } else {
                        // For all other methods, just cache by name
                        methods.put(method.getName(), method);
                    }
                }

            } catch (Exception e) {
                throw new RuntimeException("Failed to cache assembler methods", e);
            }
        }

        // Convenience methods for bytecode generation

        public void emitMagicAndVersion() throws Exception {
            methods.get("emitMagicAndVersion").invoke(assembler);
        }

        public void emitConstantPoolUTF8(String str) throws Exception {
            methods.get("emitConstantPoolUTF8").invoke(assembler, str);
        }

        public void emitConstantPoolClass(short index) throws Exception {
            methods.get("emitConstantPoolClass").invoke(assembler, index);
        }

        public void emitShort(short value) throws Exception {
            methods.get("emitShort").invoke(assembler, value);
        }

        public void emitByte(byte value) throws Exception {
            methods.get("emitByte").invoke(assembler, value);
        }

        public short getCPI() throws Exception {
            return (Short) methods.get("cpi").invoke(assembler);
        }

        // Opcode methods

        public void opc_aconst_null() throws Exception {
            methods.get("opc_aconst_null").invoke(assembler);
        }

        public void opc_return() throws Exception {
            methods.get("opc_return").invoke(assembler);
        }

        public void opc_areturn() throws Exception {
            methods.get("opc_areturn").invoke(assembler);
        }

        public void opc_invokevirtual(short methodIndex, int numArgs, int numReturnValues) throws Exception {
            methods.get("opc_invokevirtual").invoke(assembler, methodIndex, numArgs, numReturnValues);
        }

        public void opc_invokestatic(short methodIndex, int numArgs, int numReturnValues) throws Exception {
            methods.get("opc_invokestatic").invoke(assembler, methodIndex, numArgs, numReturnValues);
        }

        public void opc_new(short cpIndex) throws Exception {
            methods.get("opc_new").invoke(assembler, cpIndex);
        }

        public void opc_dup() throws Exception {
            methods.get("opc_dup").invoke(assembler);
        }

        public void opc_aload_0() throws Exception {
            methods.get("opc_aload_0").invoke(assembler);
        }

        public void opc_invokespecial(short methodIndex, int numArgs, int numReturnValues) throws Exception {
            methods.get("opc_invokespecial").invoke(assembler, methodIndex, numArgs, numReturnValues);
        }

        public void opc_ldc(byte cpIndex) throws Exception {
            methods.get("opc_ldc").invoke(assembler, cpIndex);
        }

        public void emitConstantPoolNameAndType(short nameIndex, short descIndex) throws Exception {
            methods.get("emitConstantPoolNameAndType").invoke(assembler, nameIndex, descIndex);
        }

        public void emitConstantPoolMethodref(short classIndex, short natIndex) throws Exception {
            methods.get("emitConstantPoolMethodref").invoke(assembler, classIndex, natIndex);
        }

        public void emitConstantPoolInteger(int value) throws Exception {
            methods.get("emitConstantPoolInteger").invoke(assembler, value);
        }

        public void emitInt(int value) throws Exception {
            methods.get("emitInt").invoke(assembler, value);
        }

        public void emitConstantPoolString(short utf8Index) throws Exception {
            methods.get("emitConstantPoolString").invoke(assembler, utf8Index);
        }

        public void opc_sipush(short constant) throws Exception {
            methods.get("opc_sipush").invoke(assembler, constant);
        }

        public void opc_getstatic(short fieldIndex, int fieldSizeInStackSlots) throws Exception {
            methods.get("opc_getstatic").invoke(assembler, fieldIndex, fieldSizeInStackSlots);
        }

        public void opc_putstatic(short fieldIndex, int fieldSizeInStackSlots) throws Exception {
            methods.get("opc_putstatic").invoke(assembler, fieldIndex, fieldSizeInStackSlots);
        }

        /**
         * Invoke any method on the assembler by name
         */
        public Object invoke(String methodName, Object... args) throws Exception {
            Method method = methods.get(methodName);
            if (method == null) {
                throw new IllegalArgumentException("Method not found: " + methodName);
            }
            return method.invoke(assembler, args);
        }
    }
}